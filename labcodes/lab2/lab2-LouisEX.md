### 练习一
---

1、实现最先匹配的内存分配机制

主要思路是将链表有序化，在插入和删除元素的过程中都保证有序性不变，主要修改的是default_init_memmap、default_alloc_pages、default_free_pages三个函数。由于在内存管理启用了页机制，对内存的初始化、分配、合并和回收都需要按页进行。首先对每个page初始化并加入空闲列表，从基地址base开始连续插入地址，然后遍历整个freelist，找到合适的内存块，相应地设置property和flag，并修改空闲内存块数量，最后进行合并，将base加入空闲块列表，遍历freelist找到合适的位置，相应地设置property和flag等参数，判断是否可以与相邻块合并，并修改空闲内存块数量。

2、你的first fit算法是否有进一步的改进空间

由于在代码中多次要遍历freelist查找合适的地址和内存块，目前遍历复杂度为O(n)，若能使用平衡树结构维护freelist的信息，能够将以上查找过程的复杂度优化到O(logn)。此外，在现有的页机制下都是各页维护各自的参数，如果改为按块维护，效率也会有所提升。

---
### 练习二
---

1、实现寻找虚拟地址对应的页表项

按照注释中的提示，首先根据虚拟地址找到对应一级页表的表项，判断该表项是否存在，如果不存在判断是否需要分配二级页表，若需要则设置好相关参数，得到页目录项。根据最后返回的项，将物理地址转化为虚拟地址，最后根据la得到对应的页表项。整个过程比较简单，需要注意的是返回值比较复杂。需要先将后十二位置零，转换成kernel虚址二级页表基址，然后加上偏移，返回找到二级页表项的地址。

2、请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

可在mmu.h文件中可找到以下关于每个组成部分的含义说明：

```
#define PTE_P           0x001                   // Present
#define PTE_W           0x002                   // Writeable
#define PTE_U           0x004                   // User
#define PTE_PWT         0x008                   // Write-Through
#define PTE_PCD         0x010                   // Cache-Disable
#define PTE_A           0x020                   // Accessed
#define PTE_D           0x040                   // Dirty
#define PTE_PS          0x080                   // Page Size
#define PTE_MBZ         0x180                   // Bits must be zero
#define PTE_AVAIL       0xE00                   // Available for software use
```

这些标志位使得ucore系统能够实现权限控制和保护机制，并关系到关于Cache和内存的策略的执行，还可以标记页和页表，用于寻址和访存。

3、如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

硬件先发出信号，将控制权限交给操作系统。操作系统判断异常种类，若为页缺失则从硬盘取数据放到内存中，否则需要转入中断处理服务并报错。

---
### 练习三
---

1、释放某虚地址所在的页并取消对应二级页表项的映射

按照注释中提示，首先判断二级页表是否有效，若有效则找到对应的页，并将引用次数减1，减到0时则释放，然后将二级表项清零，刷新TLB即可。

2、数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

有对应关系，注意到pmm.c中的以下代码
```
npage = maxpa / PGSIZE; 
pages = (struct Page *)ROUNDUP((void *)end, PGSIZE); 
for (i = 0; i < npage; i ++) {
    SetPageReserved(pages + i); 
}
uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
```
可以看出页表是从以end开始的一段连续内存空间存放的。

3、如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？

原代码中GCC编译器编译出的虚拟地址从0xC0000000开始，欲使虚拟地址与物理地址相等，只需修改pmm.h和pmm.c中与地址映射相关的部分，使其变为从0x100000开始即可。

---
### Others
---

1、与标准答案的区别

由于练习1我也采用了页机制管理内存，练习2和练习3都是根据注释的提示完成，因此与答案的实现方式没有根本性的差别，只有代码结构的差别，例如我的练习2和练习3都是实现了if 1的情况，保留了原来的if 0，而答案直接取消了if判断。

2、涉及的重要知识点

内存管理、内存分配算法、物理内存到虚拟内存的映射、页表、多级页表项间的映射。

3、未在实验中体现的知识点

发生缺页时的处理。



















